#!/bin/bash

# Modular Initialization
[[ $- != *i* ]] && return # Exit if not interactive

# ────────────────────────────── PATH ────────────────────────────────
export PATH="$HOME/.local/bin:$HOME/bin:$PATH"
export PATH="$HOME/.cargo/bin:$PATH"
export PATH="$HOME/anaconda3/bin:$PATH"
export PATH="$HOME/.nvm/versions/node/current/bin:$PATH"
export PATH="/home/ranuga/snap/code/183/.local/share/../bin:$PATH"

# ────────────────────────── Color palette ────────────────────────────

export GIT_COLOR='\[\e[38;5;221m\]'         # Yellow for git status
export PROMPT_DECO_COLOR='\[\e[38;5;240m\]' # Muted gray for decorative elements
export USER_COLOR='\[\e[38;5;109m\]'        # Soft teal for username
export HOST_COLOR='\[\e[38;5;174m\]'        # Muted rose for hostname
export PATH_COLOR='\[\e[38;5;143m\]'        # Soft olive green for path
export RESET_COLOR='\[\e[0m\]'              # Reset to default

# ────────────────────────── Environment ────────────────────────────
export EDITOR='nvim'
export TERMINAL='wezterm'
export BROWSER='zen'
export LANG='en_US.UTF-8'
export TERM='xterm-256color'

# ───────────────────────── Shell Options ───────────────────────────
shopt -s autocd       # Type directory to cd
shopt -s cdspell      # Autocorrect cd typos
shopt -s dirspell     # Spelling correction for directories
shopt -s checkwinsize # Update window size after commands
shopt -s globstar     # Recursive globbing
shopt -s histappend   # Append to history
set -o vi             # Vi mode in bash

# ────────────────────────── Color Setup ────────────────────────────
if [[ -f /usr/bin/dircolors ]]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
fi

# ────────────────────────── System Info Function ────────────────────────────
function show_system_info() {
    # Colors
    local RED='\e[38;5;202m'  # Ubuntu orange
    local WHITE='\e[97m'      # Bright white
    local INFO='\e[38;5;251m' # Info text color
    local RESET='\e[0m'       # Reset color

    # System information with proper error handling
    local USER=$(whoami)
    local HOSTNAME=$(hostname)
    local OS=$(lsb_release -ds 2>/dev/null || cat /etc/*release 2>/dev/null | head -n1 || echo "Unknown")
    local KERNEL=$(uname -r)
    local UPTIME=$(uptime -p | sed 's/up //')
    local PACKAGES=$(dpkg -l 2>/dev/null | grep -c '^ii' || echo "Unknown")
    local SHELL=$(basename "$SHELL")
    local MEMORY=$(free -h | awk '/^Mem:/ {printf "%s/%s", $3, $2}')
    local CPU=$(lscpu | grep "Model name" | sed 's/Model name:[[:space:]]*//g')

    # Calculate padding for alignment (longest label + 2 spaces)
    local padding=11 # Length of "Hostname: " as base padding

    # Print Ubuntu logo with system information
    echo -e "
${RED}              .-/+oossssoo+/-.               ${WHITE}User:${RESET}     ${INFO}${USER}${RESET}
${RED}          \`:+ssssssssssssssssss+:\`           ${WHITE}Hostname:${RESET} ${INFO}${HOSTNAME}${RESET}
${RED}        -+ssssssssssssssssssyyssss+-         ${WHITE}OS:${RESET}       ${INFO}${OS}${RESET}
${RED}      .ossssssssssssssssss${WHITE}dMMMNy${RED}sssso.       ${WHITE}Kernel:${RESET}   ${INFO}${KERNEL}${RESET}
${RED}     /sssssssssss${WHITE}hdmmNNmmyNMMMMh${RED}ssssss\      ${WHITE}Uptime:${RESET}   ${INFO}${UPTIME}${RESET}
${RED}    +sssssssss${WHITE}hm${RED}yd${WHITE}MMMMMMMNddddy${RED}ssssssss+     ${WHITE}Packages:${RESET} ${INFO}${PACKAGES}${RESET}
${RED}   /ssssssss${WHITE}hNMMM${RED}yh${WHITE}hyyyyhmNMMMNh${RED}ssssssss\    ${WHITE}Shell:${RESET}    ${INFO}${SHELL}${RESET}
${RED}  .ssssssss${WHITE}dMMMNh${RED}ssssssssss${WHITE}hNMMMd${RED}ssssssss.   ${WHITE}Memory:${RESET}   ${INFO}${MEMORY}${RESET}
${RED}  +ssss${WHITE}hhhyNMMNy${RED}ssssssssssss${WHITE}yNMMMy${RED}ssssssss+  ${WHITE}CPU:${RESET}      ${INFO}${CPU}${RESET}
${RED}  oss${WHITE}yNMMMNyMMh${RED}ssssssssssssss${WHITE}hmmmh${RED}ssssssso
${RED}  oss${WHITE}yNMMMNyMMh${RED}sssssssssssssshmmmh${RED}ssssssso
${RED}  +ssss${WHITE}hhhyNMMNy${RED}ssssssssssss${WHITE}yNMMMy${RED}ssssssss+
${RED}  .ssssssss${WHITE}dMMMNh${RED}ssssssssss${WHITE}hNMMMd${RED}ssssssss.
${RED}   \ssssssss${WHITE}hNMMM${RED}yh${WHITE}hyyyyhdNMMMNh${RED}ssssssss/
${RED}    +sssssssss${WHITE}dm${RED}yd${WHITE}MMMMMMMMddddy${RED}ssssssss+
${RED}     \sssssssssss${WHITE}hdmNNNNmyNMMMMh${RED}ssssss/
${RED}      .ossssssssssssssssss${WHITE}dMMMNy${RED}sssso.
${RED}        -+sssssssssssssssss${WHITE}yyy${RED}ssss+-
${RED}          \`:+ssssssssssssssssss+:\`
${RED}              .-/+oossssoo+/-.${RESET}
"
}

# ────────────────────────── Load Environment Variables ────────────────────────────
# Add this in the Special Functions section
load_env() {
    local env_file="${1:-.env}"
    if [[ -f "$env_file" ]]; then
        while IFS='=' read -r key value || [[ -n "$key" ]]; do
            # Skip comments and empty lines
            [[ $key =~ ^#.*$ ]] || [[ -z "$key" ]] && continue
            # Remove surrounding quotes from value if present
            value=$(echo "$value" | sed -e 's/^[[:space:]"'"'"']*//g' -e 's/[[:space:]"'"'"']*$//g')
            # Export the variable
            export "$key"="$value"
        done <"$env_file"
        echo "Loaded environment variables from $env_file"
    else
        echo "No $env_file file found"
    fi
}

# ────────────────────────── MongoDB Setup ────────────────────────────
run_mongo_container() {
    local container_name="mongo-container"

    # Check if container exists, stop and remove it
    if docker ps -a --filter "name=^/${container_name}$" --format "{{.Names}}" | grep -q "^${container_name}$"; then
        echo "Container ${container_name} already exists. Stopping and removing it..."
        docker stop ${container_name} >/dev/null 2>&1
        docker rm ${container_name} >/dev/null 2>&1
    fi

    # Run the MongoDB container in detached mode
    echo "Creating new MongoDB container..."
    docker run -d --name ${container_name} -p 27017:27017 mongo:latest

    # Output the connection string
    echo "mongodb://admin:password@localhost:27017/"
    echo "Container started successfully."
}

# ────────────────────────── Prompt Setup ────────────────────────────
__git_status() {
    local status=$(git status -s 2>/dev/null)
    local branch=$(git symbolic-ref --short HEAD 2>/dev/null)

    if [[ -n "$branch" ]]; then
        local status_indicators=""

        # Check for uncommitted changes
        if [[ -n "$status" ]]; then
            # Count different types of changes
            local untracked=$(echo "$status" | grep -c "??")
            local modified=$(echo "$status" | grep -c "M")
            local staged=$(echo "$status" | grep -c "A")
            local deleted=$(echo "$status" | grep -c "D")

            # Build status indicators
            [[ $untracked -gt 0 ]] && status_indicators+="?"
            [[ $modified -gt 0 ]] && status_indicators+="*"
            [[ $staged -gt 0 ]] && status_indicators+="+"
            [[ $deleted -gt 0 ]] && status_indicators+="-"
        fi

        # Display branch with status indicators
        if [[ -z "$status_indicators" ]]; then
            echo " ${PROMPT_DECO_COLOR}(${branch})${RESET_COLOR}"
        else
            echo " ${PROMPT_DECO_COLOR}(${branch}${status_indicators})${RESET_COLOR}"
        fi
    fi
}

__prompt_command() {
    local EXIT="$?"
    local LIGHTNING='\342\232\241'
    local VENV_COLOR="\e[38;5;141m"

    PS1="${PROMPT_DECO_COLOR}╭${RESET_COLOR} "
    PS1+="${USER_COLOR}\u${PROMPT_DECO_COLOR}@${HOST_COLOR}\h"

    # Show Python environment (venv or conda)
    if [ -n "$VIRTUAL_ENV" ]; then
        local venv_name=$(basename "$VIRTUAL_ENV")
        PS1+=" ${PROMPT_DECO_COLOR}(${VENV_COLOR}venv:${venv_name}${PROMPT_DECO_COLOR})"
    elif [ -n "$CONDA_DEFAULT_ENV" ]; then
        PS1+=" ${PROMPT_DECO_COLOR}(${VENV_COLOR}conda:${CONDA_DEFAULT_ENV}${PROMPT_DECO_COLOR})"
    fi

    PS1+=" ${PROMPT_DECO_COLOR}▸${PATH_COLOR} \w"
    PS1+="${PROMPT_DECO_COLOR}$(__git_status)${RESET_COLOR}\n"

    if [[ $EXIT != 0 ]]; then
        PS1+="${PROMPT_DECO_COLOR}╰${RESET_COLOR} ${PROMPT_DECO_COLOR}${LIGHTNING}${RESET_COLOR} "
    else
        PS1+="${PROMPT_DECO_COLOR}╰${RESET_COLOR} ${PROMPT_DECO_COLOR}>${RESET_COLOR} "
    fi
}

PROMPT_COMMAND=__prompt_command

# ────────────────────────── History Config ────────────────────────
HISTSIZE=100000
HISTFILESIZE=200000
HISTCONTROL=ignoreboth:erasedups
HISTIGNORE="ls:cd:cd -:pwd:exit:date:* --help"

# ────────────────────────── Aliases ────────────────────────────────
# Safety & Enhanced Defaults
alias cp='cp -iv'
alias mv='mv -iv'
alias rm='rm -i'
alias mkdir='mkdir -pv'

# Navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

# Listing
alias ls='exa --color=always'
alias ll='exa -lhgF --git --color=always'
alias la='exa -lahgF --git --color=always'
alias tree='exa --tree --level=2 --color=always'
alias treeb='exa --tree --level=1 --color=always'

# System
alias df='df -h'
alias free='free -h'
alias top='htop'

# Configuration Shortcuts
alias cvc='nvim ~/.config/nvim/'
alias cbc='nvim ~/.config/bash/'

# Git
alias g='git'
alias ga='git add'
alias gs='git status'
alias gd='git diff'
alias gc='git commit -m'
alias gca='git commit --amend'
alias gcb='git checkout -b'
alias gb='git branch'
alias gl='git log'
alias gpl='git pull'
alias gpr='git push origin'
alias gf='git fetch'

# Python
alias py='python'
alias py3='python3'
alias pipi='pip install'

## Ruff
alias rc='ruff check'
alias rcf='ruff check --fix'
alias rf='ruff format'

# Directory
alias mkd='mkdir -p'
alias rmf='rm -rf'

# Bash
alias reload='source ~/.bashrc'

# General
alias c='clear'
alias e='exit'
alias cl='clear && ls'
alias update='sudo apt-get update && sudo apt-get upgrade'
alias openapps='google-chrome & spotify & github-desktop & code &'

# ────────────────────────── Special Functions ────────────────────────────
extract() {
    for archive in $*; do
        if [ -f $archive ]; then
            case $archive in
            *.tar.bz2) tar xvjf $archive ;;
            *.tar.gz) tar xvzf $archive ;;
            *.bz2) bunzip2 $archive ;;
            *.rar) rar x $archive ;;
            *.gz) gunzip $archive ;;
            *.tar) tar xvf $archive ;;
            *.tbz2) tar xvjf $archive ;;
            *.tgz) tar xvzf $archive ;;
            *.zip) unzip $archive ;;
            *.Z) uncompress $archive ;;
            *.7z) 7z x $archive ;;
            *) echo "don't know how to extract '$archive'..." ;;
            esac
        else
            echo "'$archive' is not a valid file!"
        fi
    done
}

# ────────────────────────── Audio Transcription ────────────────────────────
transcribe_audio() {
    local input_file=""
    local model="medium"
    local language="en"
    local task="transcribe"
    local output_format="txt"
    local show_help=false

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
        -i | --input)
            input_file="$2"
            shift 2
            ;;
        -m | --model)
            model="$2"
            shift 2
            ;;
        -l | --language)
            language="$2"
            shift 2
            ;;
        -t | --task)
            task="$2"
            shift 2
            ;;
        -f | --format)
            output_format="$2"
            shift 2
            ;;
        -h | --help)
            show_help=true
            shift
            ;;
        *)
            if [[ -z "$input_file" ]]; then
                input_file="$1"
            fi
            shift
            ;;
        esac
    done

    # Show help if requested
    if [[ "$show_help" == true ]]; then
        echo "Usage: transcribe_audio [OPTIONS] INPUT_FILE"
        echo ""
        echo "Transcribe audio files using FFmpeg and Whisper"
        echo ""
        echo "Options:"
        echo "  -i, --input FILE     Input audio file (required)"
        echo "  -m, --model MODEL    Whisper model (tiny, base, small, medium, large)"
        echo "                       Default: medium"
        echo "  -l, --language LANG  Language code (en, es, fr, de, etc.)"
        echo "                       Default: en"
        echo "  -t, --task TASK      Task type (transcribe, translate)"
        echo "                       Default: transcribe"
        echo "  -f, --format FORMAT  Output format (txt, json, srt, vtt, tsv)"
        echo "                       Default: txt"
        echo "  -h, --help           Show this help message"
        echo ""
        echo "Examples:"
        echo "  transcribe_audio audio.ogg"
        echo "  transcribe_audio -m large -l es audio.mp3"
        echo "  transcribe_audio --model base --format srt audio.wav"
        return 0
    fi

    # Check if input file is provided
    if [[ -z "$input_file" ]]; then
        echo "Error: Input file is required"
        echo "Use 'transcribe_audio --help' for usage information"
        return 1
    fi

    # Check if input file exists
    if [[ ! -f "$input_file" ]]; then
        echo "Error: Input file '$input_file' not found"
        return 1
    fi

    # Check if required tools are available
    if ! command -v ffmpeg &>/dev/null; then
        echo "Error: ffmpeg is not installed"
        echo "Install with: sudo apt install ffmpeg"
        return 1
    fi

    if ! command -v whisper &>/dev/null; then
        echo "Error: whisper is not installed"
        echo "Install with: pip install openai-whisper"
        return 1
    fi

    # Create temporary directory
    local temp_dir=$(mktemp -d)
    local temp_audio="$temp_dir/audio.wav"
    local temp_output="$temp_dir/audio"

    echo "Processing audio file: $input_file"
    echo "Model: $model | Language: $language | Task: $task | Format: $output_format"
    echo ""

    # Convert audio to the format expected by Whisper
    echo "Converting audio format..."
    if ! ffmpeg -i "$input_file" -ar 16000 -ac 1 "$temp_audio" -loglevel error; then
        echo "Error: Failed to convert audio file"
        rm -rf "$temp_dir"
        return 1
    fi

    echo "Transcribing audio..."
    # Run Whisper transcription
    if ! whisper "$temp_audio" \
        --model "$model" \
        --language "$language" \
        --task "$task" \
        --output_format "$output_format" \
        --output_dir "$temp_dir"; then
        echo "Error: Whisper transcription failed"
        rm -rf "$temp_dir"
        return 1
    fi

    # Display the result
    echo ""
    echo "Transcription result:"
    echo "────────────────────────────────────────"

    local result_file="$temp_output.$output_format"
    if [[ -f "$result_file" ]]; then
        cat "$result_file"
    else
        echo "Error: Output file not found"
        rm -rf "$temp_dir"
        return 1
    fi

    echo ""
    echo "────────────────────────────────────────"

    # Cleanup
    rm -rf "$temp_dir"
    echo "Temporary files cleaned up"
}

# Alias for convenience
alias transcribe='transcribe_audio'

# ────────────────────────── Completions ────────────────────────────
[[ -f /usr/share/bash-completion/bash_completion ]] && source /usr/share/bash-completion/bash_completion
[[ -f ~/.fzf.bash ]] && source ~/.fzf.bash

# ────────────────────────── Tool Initializations ────────────────────

# Conda
__conda_setup="$('/home/ranuga/anaconda3/bin/conda' 'shell.bash' 'hook' 2>/dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    [[ -f "/home/ranuga/anaconda3/etc/profile.d/conda.sh" ]] && source "/home/ranuga/anaconda3/etc/profile.d/conda.sh"
fi
unset __conda_setup

# NVM
export NVM_DIR="$HOME/.nvm"
[[ -s "$NVM_DIR/nvm.sh" ]] && source "$NVM_DIR/nvm.sh"
[[ -s "$NVM_DIR/bash_completion" ]] && source "$NVM_DIR/bash_completion"

# ────────────────────────── Environment Files ────────────────────────────

# Load global environment variables
[[ -f "$HOME/.env" ]] && load_env "$HOME/.env"
# Load project-specific environment variables
[[ -f "$(pwd)/.env" ]] && load_env "$(pwd)/.env"

# ────────────────────────── Local Overrides ────────────────────────

[[ -f ~/.bash_local ]] && source ~/.bash_local
[[ -f ~/.bash_private ]] && source ~/.bash_private
. "$HOME/.cargo/env"

# ────────────────────────── Launchers ──────────────────────────────

show_system_info

# pnpm
export PNPM_HOME="/home/ranuga/snap/code/194/.local/share/pnpm"
case ":$PATH:" in
*":$PNPM_HOME:"*) ;;
*) export PATH="$PNPM_HOME:$PATH" ;;
esac

# gcloud
if [ -f '/home/ranuga/google-cloud-sdk/path.bash.inc' ]; then . '/home/ranuga/google-cloud-sdk/path.bash.inc'; fi

if [ -f '/home/ranuga/google-cloud-sdk/completion.bash.inc' ]; then . '/home/ranuga/google-cloud-sdk/completion.bash.inc'; fi
export PATH="$(go env GOPATH)/bin:$PATH"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

# conda 
__conda_setup="$('/home/ranuga/micromamba/bin/conda' 'shell.bash' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/home/ranuga/micromamba/etc/profile.d/conda.sh" ]; then
        . "/home/ranuga/micromamba/etc/profile.d/conda.sh"
    else
        export PATH="/home/ranuga/micromamba/bin:$PATH"
    fi
fi
unset __conda_setup

export PATH="$HOME/.local/bin:$PATH"

source '/home/ranuga/.bash_completions/typer.sh'
